{
  "version": 3,
  "sources": [],
  "sections": [
    {"offset": {"line": 16, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/apps/shared/src/auth/client.ts"],"sourcesContent":["import { createClient, type SupabaseClient } from \"@supabase/supabase-js\";\r\nimport type { User as SupabaseUser } from \"@supabase/supabase-js\";\r\nimport type { User, AppRole } from \"./types\";\r\n\r\nconst DEFAULT_ROLE: AppRole = \"customer\";\r\n\r\n/**\r\n * Create a Supabase client for browser use.\r\n * Call from each app with env: createSupabaseClient(process.env.NEXT_PUBLIC_SUPABASE_URL!, process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!)\r\n */\r\nexport function createSupabaseClient(\r\n  url: string,\r\n  anonKey: string\r\n): SupabaseClient {\r\n  return createClient(url, anonKey);\r\n}\r\n\r\n/**\r\n * Map Supabase user + user_metadata to our User type.\r\n */\r\nexport function mapSupabaseUserToUser(supabaseUser: SupabaseUser | null): User | null {\r\n  if (!supabaseUser) return null;\r\n\r\n  const meta = (supabaseUser.user_metadata ?? {}) as {\r\n    role?: AppRole;\r\n    workspace_id?: number;\r\n    full_name?: string;\r\n    name?: string;\r\n  };\r\n  const role = meta.role ?? DEFAULT_ROLE;\r\n  const workspace_id =\r\n    typeof meta.workspace_id === \"number\" ? meta.workspace_id : null;\r\n  const name =\r\n    meta.full_name ?? meta.name ?? supabaseUser.email?.split(\"@\")[0] ?? null;\r\n\r\n  return {\r\n    id: supabaseUser.id,\r\n    email: supabaseUser.email ?? \"\",\r\n    name,\r\n    role,\r\n    workspace_id,\r\n  };\r\n}\r\n"],"names":[],"mappings":";;;;;;AAAA;;AAIA,MAAM,eAAwB;AAMvB,SAAS,qBACd,GAAW,EACX,OAAe;IAEf,OAAO,IAAA,sMAAY,EAAC,KAAK;AAC3B;AAKO,SAAS,sBAAsB,YAAiC;IACrE,IAAI,CAAC,cAAc,OAAO;IAE1B,MAAM,OAAQ,aAAa,aAAa,IAAI,CAAC;IAM7C,MAAM,OAAO,KAAK,IAAI,IAAI;IAC1B,MAAM,eACJ,OAAO,KAAK,YAAY,KAAK,WAAW,KAAK,YAAY,GAAG;IAC9D,MAAM,OACJ,KAAK,SAAS,IAAI,KAAK,IAAI,IAAI,aAAa,KAAK,EAAE,MAAM,IAAI,CAAC,EAAE,IAAI;IAEtE,OAAO;QACL,IAAI,aAAa,EAAE;QACnB,OAAO,aAAa,KAAK,IAAI;QAC7B;QACA;QACA;IACF;AACF"}},
    {"offset": {"line": 46, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/apps/shared/src/auth/user.ts"],"sourcesContent":["import type { SupabaseClient } from \"@supabase/supabase-js\";\r\nimport type { User, AppRole } from \"./types\";\r\nimport { mapSupabaseUserToUser } from \"./client\";\r\n\r\n/**\r\n * Get the current authenticated user from Supabase.\r\n * Returns our User type with role and workspace_id from user_metadata.\r\n */\r\nexport async function getCurrentUser(\r\n  client: SupabaseClient\r\n): Promise<User | null> {\r\n  const {\r\n    data: { user: supabaseUser },\r\n    error,\r\n  } = await client.auth.getUser();\r\n  if (error || !supabaseUser) return null;\r\n  return mapSupabaseUserToUser(supabaseUser);\r\n}\r\n\r\n/**\r\n * Get the user's role from our User (from auth.users.user_metadata.role).\r\n */\r\nexport function getRole(user: User): AppRole {\r\n  return user.role;\r\n}\r\n\r\n/**\r\n * Get the user's workspace_id from our User (from auth.users.user_metadata.workspace_id).\r\n */\r\nexport function getWorkspaceId(user: User): number | null {\r\n  return user.workspace_id;\r\n}\r\n\r\n/**\r\n * Check if the user's role is in the allowed list (for route guards).\r\n */\r\nexport function isRoleAllowed(\r\n  role: AppRole,\r\n  allowedRoles: readonly AppRole[]\r\n): boolean {\r\n  return allowedRoles.includes(role);\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;AAEA;;AAMO,eAAe,eACpB,MAAsB;IAEtB,MAAM,EACJ,MAAM,EAAE,MAAM,YAAY,EAAE,EAC5B,KAAK,EACN,GAAG,MAAM,OAAO,IAAI,CAAC,OAAO;IAC7B,IAAI,SAAS,CAAC,cAAc,OAAO;IACnC,OAAO,IAAA,wKAAqB,EAAC;AAC/B;AAKO,SAAS,QAAQ,IAAU;IAChC,OAAO,KAAK,IAAI;AAClB;AAKO,SAAS,eAAe,IAAU;IACvC,OAAO,KAAK,YAAY;AAC1B;AAKO,SAAS,cACd,IAAa,EACb,YAAgC;IAEhC,OAAO,aAAa,QAAQ,CAAC;AAC/B"}},
    {"offset": {"line": 76, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/apps/shared/src/auth/access.ts"],"sourcesContent":["import type { AppRole } from \"./types\";\r\nimport { isRoleAllowed } from \"./user\";\r\n\r\n/**\r\n * Allowed roles per app â€“ single source of truth for final access validation.\r\n * - Superadmin cannot access workspace app.\r\n * - Workspace admin cannot access superadmin app.\r\n * - Customer can access workspace app only.\r\n * - Invalid users are redirected to login (enforced by proxy + login page).\r\n */\r\nexport const SUPERADMIN_APP_ROLES: readonly AppRole[] = [\"superadmin\"];\r\nexport const WORKSPACE_APP_ROLES: readonly AppRole[] = [\r\n  \"superadmin\",\r\n  \"workspace_admin\",\r\n  \"customer\",\r\n];\r\n\r\nexport type AppName = \"superadmin\" | \"workspace\";\r\n\r\nconst APP_ROLES: Record<AppName, readonly AppRole[]> = {\r\n  superadmin: SUPERADMIN_APP_ROLES,\r\n  workspace: WORKSPACE_APP_ROLES,\r\n};\r\n\r\n/**\r\n * Final access validation: can this role access this app?\r\n * Use in proxy (route guard) and login (after sign-in).\r\n */\r\nexport function canAccessApp(role: AppRole, app: AppName): boolean {\r\n  return isRoleAllowed(role, APP_ROLES[app]);\r\n}\r\n\r\n/**\r\n * Get allowed roles for an app (for error messages / UI).\r\n */\r\nexport function getAllowedRolesForApp(app: AppName): readonly AppRole[] {\r\n  return APP_ROLES[app];\r\n}\r\n"],"names":[],"mappings":";;;;;;;;;;AACA;;AASO,MAAM,uBAA2C;IAAC;CAAa;AAC/D,MAAM,sBAA0C;IACrD;IACA;IACA;CACD;AAID,MAAM,YAAiD;IACrD,YAAY;IACZ,WAAW;AACb;AAMO,SAAS,aAAa,IAAa,EAAE,GAAY;IACtD,OAAO,IAAA,8JAAa,EAAC,MAAM,SAAS,CAAC,IAAI;AAC3C;AAKO,SAAS,sBAAsB,GAAY;IAChD,OAAO,SAAS,CAAC,IAAI;AACvB"}},
    {"offset": {"line": 110, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/apps/shared/src/auth/session.ts"],"sourcesContent":["import type { SupabaseClient } from \"@supabase/supabase-js\";\r\nimport type { Session } from \"./types\";\r\nimport { getCurrentUser } from \"./user\";\r\n\r\n/**\r\n * Get the current session (user + expiry) from Supabase.\r\n * Use getCurrentUser(client) for just the user.\r\n */\r\nexport async function getSession(\r\n  client: SupabaseClient\r\n): Promise<Session | null> {\r\n  const user = await getCurrentUser(client);\r\n  if (!user) return null;\r\n\r\n  const {\r\n    data: { session: supabaseSession },\r\n  } = await client.auth.getSession();\r\n  const expiresAt = supabaseSession?.expires_at\r\n    ? supabaseSession.expires_at * 1000\r\n    : 0;\r\n\r\n  return {\r\n    user,\r\n    expiresAt,\r\n  };\r\n}\r\n\r\n/**\r\n * Sign out the current user via Supabase.\r\n */\r\nexport async function signOut(client: SupabaseClient): Promise<void> {\r\n  await client.auth.signOut();\r\n}\r\n"],"names":[],"mappings":";;;;;;AAEA;;AAMO,eAAe,WACpB,MAAsB;IAEtB,MAAM,OAAO,MAAM,IAAA,+JAAc,EAAC;IAClC,IAAI,CAAC,MAAM,OAAO;IAElB,MAAM,EACJ,MAAM,EAAE,SAAS,eAAe,EAAE,EACnC,GAAG,MAAM,OAAO,IAAI,CAAC,UAAU;IAChC,MAAM,YAAY,iBAAiB,aAC/B,gBAAgB,UAAU,GAAG,OAC7B;IAEJ,OAAO;QACL;QACA;IACF;AACF;AAKO,eAAe,QAAQ,MAAsB;IAClD,MAAM,OAAO,IAAI,CAAC,OAAO;AAC3B"}},
    {"offset": {"line": 135, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/apps/shared/src/auth/logout.ts"],"sourcesContent":["import type { SupabaseClient } from \"@supabase/supabase-js\";\r\n\r\n/** Keys that may hold auth/session data in storage (clear on logout). */\r\nconst AUTH_STORAGE_KEYS = [\r\n  \"sb-\",\r\n  // Supabase uses sb-<project-ref>-auth-token; prefix covers all\r\n] as const;\r\n\r\n/**\r\n * Clear any cached auth-related data from localStorage/sessionStorage.\r\n * Supabase signOut() clears its own keys; this clears any app-specific or residual keys.\r\n */\r\nfunction clearAuthStorage(): void {\r\n  if (typeof window === \"undefined\") return;\r\n  try {\r\n    const keysToRemove: string[] = [];\r\n    for (let i = 0; i < localStorage.length; i++) {\r\n      const key = localStorage.key(i);\r\n      if (key && AUTH_STORAGE_KEYS.some((prefix) => key.startsWith(prefix))) {\r\n        keysToRemove.push(key);\r\n      }\r\n    }\r\n    keysToRemove.forEach((key) => localStorage.removeItem(key));\r\n    const sessionKeysToRemove: string[] = [];\r\n    for (let i = 0; i < sessionStorage.length; i++) {\r\n      const key = sessionStorage.key(i);\r\n      if (key && AUTH_STORAGE_KEYS.some((prefix) => key.startsWith(prefix))) {\r\n        sessionKeysToRemove.push(key);\r\n      }\r\n    }\r\n    sessionKeysToRemove.forEach((key) => sessionStorage.removeItem(key));\r\n  } catch {\r\n    // Ignore storage errors (e.g. private mode)\r\n  }\r\n}\r\n\r\n/**\r\n * Shared logout handler: sign out from Supabase and clear local auth/cached data.\r\n * Use this in both Superadmin and Workspace apps. After calling, clear React auth state\r\n * (e.g. AuthContext setUser(null)) and redirect to the app's login page.\r\n */\r\nexport async function performLogout(client: SupabaseClient | null): Promise<void> {\r\n  if (client) {\r\n    await client.auth.signOut();\r\n  }\r\n  clearAuthStorage();\r\n}\r\n"],"names":[],"mappings":";;;;AAEA,uEAAuE,GACvE,MAAM,oBAAoB;IACxB;CAED;AAED;;;CAGC,GACD,SAAS;IACP,wCAAmC;;;AAqBrC;AAOO,eAAe,cAAc,MAA6B;IAC/D,IAAI,QAAQ;QACV,MAAM,OAAO,IAAI,CAAC,OAAO;IAC3B;IACA;AACF"}},
    {"offset": {"line": 160, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/apps/shared/src/auth/AuthContext.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const AuthProvider = registerClientReference(\n    function() { throw new Error(\"Attempted to call AuthProvider() from the server but AuthProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/apps/shared/src/auth/AuthContext.tsx <module evaluation>\",\n    \"AuthProvider\",\n);\nexport const useAuth = registerClientReference(\n    function() { throw new Error(\"Attempted to call useAuth() from the server but useAuth is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/apps/shared/src/auth/AuthContext.tsx <module evaluation>\",\n    \"useAuth\",\n);\n"],"names":[],"mappings":";;;;;;AAAA,uEAAuE;AACvE;;AACO,MAAM,eAAe,IAAA,oOAAuB,EAC/C;IAAa,MAAM,IAAI,MAAM;AAAwO,GACrQ,sEACA;AAEG,MAAM,UAAU,IAAA,oOAAuB,EAC1C;IAAa,MAAM,IAAI,MAAM;AAA8N,GAC3P,sEACA","ignoreList":[0]}},
    {"offset": {"line": 179, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/apps/shared/src/auth/AuthContext.tsx/__nextjs-internal-proxy.mjs"],"sourcesContent":["// This file is generated by next-core EcmascriptClientReferenceModule.\nimport { registerClientReference } from \"react-server-dom-turbopack/server\";\nexport const AuthProvider = registerClientReference(\n    function() { throw new Error(\"Attempted to call AuthProvider() from the server but AuthProvider is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/apps/shared/src/auth/AuthContext.tsx\",\n    \"AuthProvider\",\n);\nexport const useAuth = registerClientReference(\n    function() { throw new Error(\"Attempted to call useAuth() from the server but useAuth is on the client. It's not possible to invoke a client function from the server, it can only be rendered as a Component or passed to props of a Client Component.\"); },\n    \"[project]/apps/shared/src/auth/AuthContext.tsx\",\n    \"useAuth\",\n);\n"],"names":[],"mappings":";;;;;;AAAA,uEAAuE;AACvE;;AACO,MAAM,eAAe,IAAA,oOAAuB,EAC/C;IAAa,MAAM,IAAI,MAAM;AAAwO,GACrQ,kDACA;AAEG,MAAM,UAAU,IAAA,oOAAuB,EAC1C;IAAa,MAAM,IAAI,MAAM;AAA8N,GAC3P,kDACA","ignoreList":[0]}},
    {"offset": {"line": 198, "column": 0}, "map": {"version":3,"sources":[],"names":[],"mappings":""}},
    {"offset": {"line": 206, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/apps/shared/src/auth/index.ts"],"sourcesContent":["export type { User, Session, AppRole, UserMetadata } from \"./types\";\r\nexport { createSupabaseClient, mapSupabaseUserToUser } from \"./client\";\r\nexport { getCurrentUser, getRole, getWorkspaceId, isRoleAllowed } from \"./user\";\r\nexport {\r\n  SUPERADMIN_APP_ROLES,\r\n  WORKSPACE_APP_ROLES,\r\n  canAccessApp,\r\n  getAllowedRolesForApp,\r\n} from \"./access\";\r\nexport type { AppName } from \"./access\";\r\nexport { getSession, signOut } from \"./session\";\r\nexport { performLogout } from \"./logout\";\r\nexport { AuthProvider, useAuth } from \"./AuthContext\";\r\nexport type { AuthProviderProps, AuthContextValue } from \"./AuthContext\";\r\n"],"names":[],"mappings":";AACA;AACA;AACA;AAOA;AACA;AACA"}},
    {"offset": {"line": 223, "column": 0}, "map": {"version":3,"sources":["turbopack:///[project]/apps/superadmin/middleware.ts"],"sourcesContent":["import { NextResponse, type NextRequest } from \"next/server\";\r\nimport { createServerClient } from \"@supabase/ssr\";\r\nimport { getCurrentUser, getRole, canAccessApp } from \"@crm/shared/auth\";\r\nimport type { AppRole } from \"@crm/shared/auth\";\r\n\r\nconst LOGIN_PATH = \"/login\";\r\n\r\nexport async function middleware(request: NextRequest) {\r\n  let response = NextResponse.next({ request });\r\n\r\n  const url = process.env.NEXT_PUBLIC_SUPABASE_URL;\r\n  const anonKey = process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY;\r\n  if (!url || !anonKey) {\r\n    return response;\r\n  }\r\n\r\n  const supabase = createServerClient(url, anonKey, {\r\n    cookies: {\r\n      getAll() {\r\n        return request.cookies.getAll();\r\n      },\r\n      setAll(cookiesToSet: { name: string; value: string; options?: object }[]) {\r\n        cookiesToSet.forEach(({ name, value, options }) =>\r\n          response.cookies.set(name, value, options)\r\n        );\r\n      },\r\n    },\r\n  });\r\n\r\n  const user = await getCurrentUser(supabase);\r\n  const isLoginPage = request.nextUrl.pathname === LOGIN_PATH;\r\n\r\n  if (!user) {\r\n    if (isLoginPage) return response;\r\n    return NextResponse.redirect(new URL(LOGIN_PATH, request.url));\r\n  }\r\n\r\n  const role = getRole(user);\r\n  if (!canAccessApp(role, \"superadmin\")) {\r\n    if (isLoginPage) return response;\r\n    return NextResponse.redirect(new URL(LOGIN_PATH, request.url));\r\n  }\r\n\r\n  if (isLoginPage) {\r\n    return NextResponse.redirect(new URL(\"/\", request.url));\r\n  }\r\n\r\n  return response;\r\n}"],"names":[],"mappings":";;;;AAAA;AAAA;AACA;AAAA;AACA;AAAA;AAAA;;;;AAGA,MAAM,aAAa;AAEZ,eAAe,WAAW,OAAoB;IACnD,IAAI,WAAW,gMAAY,CAAC,IAAI,CAAC;QAAE;IAAQ;IAE3C,MAAM;IACN,MAAM;IACN;;IAIA,MAAM,WAAW,IAAA,uMAAkB,EAAC,KAAK,SAAS;QAChD,SAAS;YACP;gBACE,OAAO,QAAQ,OAAO,CAAC,MAAM;YAC/B;YACA,QAAO,YAAiE;gBACtE,aAAa,OAAO,CAAC,CAAC,EAAE,IAAI,EAAE,KAAK,EAAE,OAAO,EAAE,GAC5C,SAAS,OAAO,CAAC,GAAG,CAAC,MAAM,OAAO;YAEtC;QACF;IACF;IAEA,MAAM,OAAO,MAAM,IAAA,+JAAc,EAAC;IAClC,MAAM,cAAc,QAAQ,OAAO,CAAC,QAAQ,KAAK;IAEjD,IAAI,CAAC,MAAM;QACT,IAAI,aAAa,OAAO;QACxB,OAAO,gMAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,YAAY,QAAQ,GAAG;IAC9D;IAEA,MAAM,OAAO,IAAA,wJAAO,EAAC;IACrB,IAAI,CAAC,IAAA,+JAAY,EAAC,MAAM,eAAe;QACrC,IAAI,aAAa,OAAO;QACxB,OAAO,gMAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,YAAY,QAAQ,GAAG;IAC9D;IAEA,IAAI,aAAa;QACf,OAAO,gMAAY,CAAC,QAAQ,CAAC,IAAI,IAAI,KAAK,QAAQ,GAAG;IACvD;IAEA,OAAO;AACT"}}]
}